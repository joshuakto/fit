/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_LOCAL_STORE: () => DEFAULT_LOCAL_STORE,
  DEFAULT_REPOSITORY: () => DEFAULT_REPOSITORY,
  default: () => FitPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/const.ts
var rootFitFolder = "_fit";
var conflictReportPath = rootFitFolder + "/report-conflict.md";
var conflictResolutionFolder = rootFitFolder + "/conflict/";
var basicTemplateConflict = "<<<---";

// node_modules/@octokit/core/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/index.js
function getUserAgent2() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent2()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/node_modules/universal-user-agent/index.js
function getUserAgent3() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    // Header values must be `string`
    headers: Object.fromEntries(
      Object.entries(requestOptions.headers).map(([name, value]) => [
        name,
        String(value)
      ])
    ),
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent3()}`
  }
});

// node_modules/@octokit/graphql/node_modules/universal-user-agent/index.js
function getUserAgent4() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent4()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// src/utils.ts
var import_obsidian = require("obsidian");

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return void 0;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            const oldValue = oldTokens[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/util/string.js
function longestCommonPrefix(str1, str2) {
  let i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  let i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  let startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  let endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  const map = Array(endB);
  let k = 0;
  map[0] = 0;
  for (let j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map[j] = map[k];
    } else {
      map[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (let i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
function trailingWs(string) {
  let i;
  for (i = string.length - 1; i >= 0; i--) {
    if (!string[i].match(/\s/)) {
      break;
    }
  }
  return string.substring(i + 1);
}
function leadingWs(string) {
  const match = string.match(/^\s*/);
  return match ? match[0] : "";
}

// node_modules/diff/libesm/diff/word.js
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\s+|[^${extendedWordChars}]`, "ug");
var WordDiff = class extends Diff {
  equals(left, right, options) {
    if (options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left.trim() === right.trim();
  }
  tokenize(value, options = {}) {
    let parts;
    if (options.intlSegmenter) {
      const segmenter = options.intlSegmenter;
      if (segmenter.resolvedOptions().granularity != "word") {
        throw new Error('The segmenter passed must have a granularity of "word"');
      }
      parts = Array.from(segmenter.segment(value), (segment) => segment.segment);
    } else {
      parts = value.match(tokenizeIncludingWhitespace) || [];
    }
    const tokens = [];
    let prevPart = null;
    parts.forEach((part) => {
      if (/\s/.test(part)) {
        if (prevPart == null) {
          tokens.push(part);
        } else {
          tokens.push(tokens.pop() + part);
        }
      } else if (prevPart != null && /\s/.test(prevPart)) {
        if (tokens[tokens.length - 1] == prevPart) {
          tokens.push(tokens.pop() + part);
        } else {
          tokens.push(prevPart + part);
        }
      } else {
        tokens.push(part);
      }
      prevPart = part;
    });
    return tokens;
  }
  join(tokens) {
    return tokens.map((token, i) => {
      if (i == 0) {
        return token;
      } else {
        return token.replace(/^\s+/, "");
      }
    }).join("");
  }
  postProcess(changes, options) {
    if (!changes || options.oneChangePerToken) {
      return changes;
    }
    let lastKeep = null;
    let insertion = null;
    let deletion = null;
    changes.forEach((change) => {
      if (change.added) {
        insertion = change;
      } else if (change.removed) {
        deletion = change;
      } else {
        if (insertion || deletion) {
          dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
        }
        lastKeep = change;
        insertion = null;
        deletion = null;
      }
    });
    if (insertion || deletion) {
      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
    }
    return changes;
  }
};
var wordDiff = new WordDiff();
function diffWords(oldStr, newStr, options) {
  if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {
    return diffWordsWithSpace(oldStr, newStr, options);
  }
  return wordDiff.diff(oldStr, newStr, options);
}
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    const oldWsPrefix = leadingWs(deletion.value);
    const oldWsSuffix = trailingWs(deletion.value);
    const newWsPrefix = leadingWs(insertion.value);
    const newWsSuffix = trailingWs(insertion.value);
    if (startKeep) {
      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      const ws = leadingWs(insertion.value);
      insertion.value = insertion.value.substring(ws.length);
    }
    if (endKeep) {
      const ws = leadingWs(endKeep.value);
      endKeep.value = endKeep.value.substring(ws.length);
    }
  } else if (startKeep && endKeep) {
    const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);
    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    const endKeepWsPrefix = leadingWs(endKeep.value);
    const deletionWsSuffix = trailingWs(deletion.value);
    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    const startKeepWsSuffix = trailingWs(startKeep.value);
    const deletionWsPrefix = leadingWs(deletion.value);
    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, overlap);
  }
}
var WordsWithSpaceDiff = class extends Diff {
  tokenize(value) {
    const regex = new RegExp(`(\\r?\\n)|[${extendedWordChars}]+|[^\\S\\n\\r]+|[^${extendedWordChars}]`, "ug");
    return value.match(regex) || [];
  }
};
var wordsWithSpaceDiff = new WordsWithSpaceDiff();
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordsWithSpaceDiff.diff(oldStr, newStr, options);
}

// src/utils.ts
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var RECOGNIZED_TXT_EXT = ["txt", "md"];
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function isBinaryFile(path) {
  const extension = extractExtension(path);
  const isTxt = extension && RECOGNIZED_TXT_EXT.includes(extension);
  return !isTxt;
}
function removeLineEndingsFromBase64String(content) {
  return content.replace(/\r?\n|\r|\n/g, "");
}
function showFileOpsRecord(records) {
  if (records.length === 0 || records.every((r) => r.ops.length === 0)) {
    return;
  }
  const fileOpsNotice = new import_obsidian.Notice("", 0);
  records.map((recordSet) => {
    if (recordSet.ops.length === 0) {
      return;
    }
    const heading = fileOpsNotice.noticeEl.createEl("span", {
      cls: "file-changes-heading"
    });
    heading.setText(`${recordSet.heading}
`);
    const fileChanges = {
      created: [],
      changed: [],
      deleted: []
    };
    for (const op of recordSet.ops) {
      fileChanges[op.status].push(op.path);
    }
    for (const [changeType, paths] of Object.entries(fileChanges)) {
      if (paths.length === 0) {
        continue;
      }
      const heading2 = fileOpsNotice.noticeEl.createEl("span");
      heading2.setText(`${changeType.charAt(0).toUpperCase() + changeType.slice(1)}
`);
      heading2.addClass(`file-changes-subheading`);
      for (const path of paths) {
        const listItem = fileOpsNotice.noticeEl.createEl("li", {
          cls: "file-update-row"
        });
        listItem.setText(`${path}`);
        listItem.addClass(`file-${changeType}`);
      }
    }
  });
}
function showUnappliedConflicts(clashedFiles) {
  if (clashedFiles.length === 0) {
    return;
  }
  const localStatusMap = {
    created: "create",
    changed: "change",
    deleted: "delete"
  };
  const remoteStatusMap = {
    ADDED: "create",
    MODIFIED: "change",
    REMOVED: "delete"
  };
  const conflictNotice = new import_obsidian.Notice("", 0);
  const heading = conflictNotice.noticeEl.createEl("span");
  heading.setText(`Change conflicts:
`);
  heading.addClass(`file-changes-subheading`);
  const conflictStatus = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  conflictStatus.createDiv().setText("Local");
  conflictStatus.createDiv().setText("Remote");
  for (const clash of clashedFiles) {
    const conflictItem = conflictNotice.noticeEl.createDiv({
      cls: "file-conflict-row"
    });
    conflictItem.createDiv({
      cls: `file-conflict-${localStatusMap[clash.localStatus]}`
    });
    conflictItem.createDiv("div").setText(clash.path);
    conflictItem.createDiv({
      cls: `file-conflict-${remoteStatusMap[clash.remoteStatus]}`
    });
  }
  const footer = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  footer.setText("Note:");
  footer.style.fontWeight = "bold";
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText(`Remote changes in ${conflictResolutionFolder}`);
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText(`${conflictResolutionFolder} folder is overwritten on conflict, copy needed changes outside ${conflictResolutionFolder}.`);
}
function difference(setA, setB) {
  return new Set([...setA].filter((x) => !setB.has(x)));
}
function getDiffText(oldContent, newContent) {
  let result = "";
  const diff = diffWords(oldContent, newContent);
  const hasChanges = diff.some((part) => part.added || part.removed);
  if (!hasChanges) {
    return basicTemplateConflict + "No differences found";
  }
  let currentLine = "";
  let hasLineChanges = false;
  for (let part of diff) {
    let text;
    if (part.removed) {
      text = `<span style="color:rgb(223, 73, 73)">${part.value}</span>`;
    } else if (part.added) {
      text = `<span style="color:rgb(0, 176, 80)">${part.value}</span>`;
    } else {
      text = part.value;
    }
    const lines = text.split("\n");
    currentLine += lines[0];
    if (part.added || part.removed) {
      hasLineChanges = true;
    }
    for (let i = 1; i < lines.length; i++) {
      if (hasLineChanges) {
        result += currentLine + "\n";
      }
      currentLine = lines[i];
      hasLineChanges = part.added || part.removed;
    }
  }
  if (hasLineChanges && currentLine) {
    result += currentLine + "\n";
  }
  return result;
}

// src/fit.ts
var import_obsidian2 = require("obsidian");
var OctokitHttpError = class extends Error {
  constructor(message, status, source) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.source = source;
  }
};
var Fit = class {
  constructor(repo, vaultOps) {
    this.loadSettings(repo);
    this.vaultOps = vaultOps;
    this.headers = {
      // Hack to disable caching which leads to inconsistency for
      // read after write https://github.com/octokit/octokit.js/issues/890
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  loadSettings(repo) {
    const { settings, localStore } = repo;
    this.repo = settings.repo;
    this.owner = settings.owner;
    this.branch = settings.branch;
    this.excludes = settings.excludes;
    this.syncPath = settings.syncPath;
    this.deviceName = settings.deviceName;
    this.octokit = new Octokit({ auth: settings.pat });
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
  }
  async fileSha1(fileContent) {
    const enc = new TextEncoder();
    const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(fileContent));
    const hashArray = Array.from(new Uint8Array(hashBuf));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
  async computeFileLocalSha(path) {
    const fullPath = this.syncPath + path;
    let content;
    const file = await this.vaultOps.getTFile(fullPath);
    if (file) {
      if (RECOGNIZED_TXT_EXT.includes(file.extension)) {
        content = await this.vaultOps.vault.read(file);
      } else {
        content = (0, import_obsidian2.arrayBufferToBase64)(await this.vaultOps.vault.readBinary(file));
      }
    } else {
      const extension = extractExtension(path);
      if (!extension || !RECOGNIZED_TXT_EXT.includes(extension)) {
        content = (0, import_obsidian2.arrayBufferToBase64)(
          await this.vaultOps.vault.adapter.readBinary(fullPath)
        );
      } else {
        content = await this.vaultOps.vault.adapter.read(fullPath);
      }
    }
    return await this.fileSha1(path + content);
  }
  async computeLocalSha() {
    const allPaths = await this.vaultOps.getFilesInVault();
    const paths = [];
    for (let path of allPaths) {
      let isExcluded = path.startsWith(conflictResolutionFolder) || !path.startsWith(this.syncPath) || this.excludes.contains(path) || this.excludes.some(
        (exclude) => path.startsWith(exclude) && !this.syncPath.startsWith(exclude)
        // NOTE if one syncPath nested in another syncPath
      );
      const result2 = path.replace(this.syncPath, "");
      if (!isExcluded)
        paths.push(result2);
    }
    const asyncCompute = paths.map(
      async (path) => {
        const sha = await this.computeFileLocalSha(path);
        return [path, sha];
      }
    );
    const computed = await Promise.all(asyncCompute);
    const result = computed.filter((el) => !!el[1]);
    return Object.fromEntries(result);
  }
  async remoteUpdated() {
    const remoteCommitSha = await this.getRef();
    return { remoteCommitSha, updated: remoteCommitSha !== this.lastFetchedCommitSha };
  }
  async getLocalChanges(currentLocalSha) {
    if (!currentLocalSha) {
      currentLocalSha = await this.computeLocalSha();
    }
    const localChanges = compareSha(currentLocalSha, this.localSha, "local");
    return localChanges;
  }
  async getRemoteChanges(remoteTreeSha) {
    const remoteChanges = compareSha(remoteTreeSha, this.lastFetchedRemoteSha, "remote");
    return remoteChanges;
  }
  getClashedChanges(localChanges, remoteChanges) {
    const localChangePaths = localChanges.map(
      (c) => c.path.replace(this.syncPath, "")
    );
    const remoteChangePaths = remoteChanges.map((c) => c.path);
    const clashedFiles = localChangePaths.map(
      (path, localIndex) => {
        const remoteIndex = remoteChangePaths.indexOf(path);
        if (remoteIndex !== -1) {
          return { path, localIndex, remoteIndex };
        }
        return null;
      }
    ).filter(Boolean);
    return clashedFiles.map(
      ({ path, localIndex, remoteIndex }) => {
        return {
          path,
          localStatus: localChanges[localIndex].status,
          remoteStatus: remoteChanges[remoteIndex].status
        };
      }
    );
  }
  async getRepos() {
    const allRepos = [];
    let page = 1;
    const perPage = 100;
    try {
      let hasMorePages = true;
      while (hasMorePages) {
        const { data: response } = await this.octokit.request(
          `GET /user/repos`,
          {
            affiliation: "owner",
            headers: this.headers,
            per_page: perPage,
            // Number of repositories to import per page (up to 100)
            page
          }
        );
        allRepos.push(...response.map((r) => r.name));
        if (response.length < perPage) {
          hasMorePages = false;
        }
        page++;
      }
      return allRepos;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  // Get the sha of the latest commit in the default branch (set by user in setting)
  async getRef(ref = `heads/${this.branch}`) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRef");
    }
  }
  // ref Can be a commit SHA, branch name (heads/BRANCH_NAME), or tag name (tags/TAG_NAME),
  // refers to https://git-scm.com/book/en/v2/Git-Internals-Git-References
  async getCommitTreeSha(ref) {
    const { data: commit } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/commits/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        headers: this.headers
      }
    );
    return commit.commit.tree.sha;
  }
  async getTree(tree_sha) {
    const { data: tree } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/trees/{tree_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        tree_sha,
        recursive: "true",
        headers: this.headers
      }
    );
    return tree.tree;
  }
  // get the remote tree sha in the format compatible with local store
  async getRemoteTreeSha(tree_sha) {
    const remoteTree = await this.getTree(tree_sha);
    const remoteSha = Object.fromEntries(remoteTree.map((node) => {
      if (node.type == "blob") {
        if (!node.path || !node.sha) {
          throw new Error("Path or sha not found for blob node in remote");
        }
        if (node.path.startsWith(conflictResolutionFolder)) {
          return null;
        }
        return [node.path, node.sha];
      }
      return null;
    }).filter(Boolean));
    return remoteSha;
  }
  async createBlob(content, encoding) {
    const { data: blob } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/blobs`,
      {
        owner: this.owner,
        repo: this.repo,
        content,
        encoding,
        headers: this.headers
      }
    );
    return blob.sha;
  }
  async createTreeNodeFromFile({ path, status, extension }, remoteTree) {
    if (status === "deleted") {
      if (remoteTree.every((node) => node.path !== path)) {
        return null;
      }
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
      };
    }
    const fullPath = this.syncPath + path;
    let encoding;
    let content;
    if (extension && !RECOGNIZED_TXT_EXT.includes(extension)) {
      encoding = "base64";
      const fileArrayBuf = await this.vaultOps.vault.adapter.readBinary(fullPath);
      const uint8Array = new Uint8Array(fileArrayBuf);
      let binaryString = "";
      for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
      }
      content = btoa(binaryString);
    } else {
      encoding = "utf-8";
      content = await this.vaultOps.vault.adapter.read(fullPath);
    }
    const blobSha = await this.createBlob(content, encoding);
    if (remoteTree.some((node) => node.path === path && node.sha === blobSha)) {
      return null;
    }
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  async createTree(treeNodes, base_tree_sha) {
    const { data: newTree } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/trees`,
      {
        owner: this.owner,
        repo: this.repo,
        tree: treeNodes,
        base_tree: base_tree_sha,
        headers: this.headers
      }
    );
    return newTree.sha;
  }
  async createCommit(treeSha, parentSha) {
    const message = `Commit from ${this.deviceName} on ${new Date().toLocaleString()}`;
    const { data: createdCommit } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/commits`,
      {
        owner: this.owner,
        repo: this.repo,
        message,
        tree: treeSha,
        parents: [parentSha],
        headers: this.headers
      }
    );
    return createdCommit.sha;
  }
  async updateRef(sha, ref = `heads/${this.branch}`) {
    const { data: updatedRef } = await this.octokit.request(
      `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        sha,
        headers: this.headers
      }
    );
    return updatedRef.object.sha;
  }
  async getBlob(file_sha) {
    const { data: blob } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        file_sha,
        headers: this.headers
      }
    );
    return blob.content;
  }
  getAddToLocal(addToLocal_) {
    const basepath = this.syncPath;
    const addToLocal = structuredClone(addToLocal_);
    return addToLocal.map(
      ({ path, content }) => {
        return {
          path: basepath + path,
          content
        };
      }
    ).filter(
      (file) => {
        const excludes = this.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !file.path.startsWith(exclude) || this.syncPath.startsWith(exclude)
          // NOTE if one syncPath nested in another syncPath
        );
      }
    );
  }
  getDeleteFromLocal(deleteFromLocal_) {
    const basepath = this.syncPath;
    const deleteFromLocal = structuredClone(deleteFromLocal_);
    return deleteFromLocal.map(
      (path) => basepath + path
    ).filter(
      (path) => {
        const excludes = this.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !path.startsWith(exclude) || this.syncPath.startsWith(exclude)
          // NOTE if one syncPath nested in another syncPath
        );
      }
    );
  }
};

// src/fitNotice.ts
var import_obsidian3 = require("obsidian");
var FitNotice = class {
  constructor(addClasses = [], initialMessage, duration = 0, muted = false) {
    this.muted = muted;
    this.classes = ["fit-notice"];
    if (initialMessage && !this.muted) {
      this.show(initialMessage, addClasses, duration);
    } else {
      this.classes = [...this.classes, ...addClasses];
    }
  }
  mute() {
    this.muted = true;
    if (this.notice) {
      this.notice.hide();
    }
  }
  unmute() {
    this.muted = false;
  }
  show(initialMessage, addClasses = [], duration = 0) {
    if (!this.notice && !this.muted) {
      const message = initialMessage && initialMessage.length > 0 ? initialMessage : " ";
      this.notice = new import_obsidian3.Notice(message, duration);
      this.notice.noticeEl.addClasses([...this.classes, ...addClasses]);
    }
  }
  updateClasses(addClasses = [], removeClasses = []) {
    if (this.muted) {
      return;
    }
    this.classes = this.classes.filter((c) => !removeClasses.includes(c));
    if (this.notice) {
      this.notice.noticeEl.removeClasses(removeClasses);
      this.notice.noticeEl.addClasses(addClasses);
    }
    this.classes = [...this.classes, ...addClasses];
  }
  // allows error display to override muted
  setMessage(message, isError) {
    if (isError) {
      if (!this.notice) {
        this.notice = new import_obsidian3.Notice(message, 0);
        this.notice.noticeEl.addClasses(["fit-notice", "error"]);
      } else {
        this.notice.setMessage(message);
      }
    } else {
      if (this.notice && !this.muted) {
        this.notice.setMessage(message);
      }
    }
  }
  remove(finalClass, duration = 5e3) {
    var _a, _b, _c;
    if (this.muted) {
      return;
    }
    (_a = this.notice) == null ? void 0 : _a.noticeEl.removeClasses(this.classes.filter((c) => c !== "fit-notice"));
    if (finalClass) {
      (_b = this.notice) == null ? void 0 : _b.noticeEl.addClass(finalClass);
    } else {
      (_c = this.notice) == null ? void 0 : _c.noticeEl.addClass("done");
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = this.notice) == null ? void 0 : _a2.hide();
    }, duration);
  }
};

// src/fitSetting.ts
var import_obsidian4 = require("obsidian");
var FitSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    // patSetting: Setting;
    // ownerSetting: Setting;
    // repoSetting: Setting;
    // branchSetting: Setting;
    // syncPathSetting: Setting;
    // existingRepos: Array<string>;
    // existingBranches: Array<string>;
    // repoLink: string;
    // syncPath: string;
    this.currentSyncIndex = 0;
    this.getLatestLink = () => {
      const currentSetting = this.getCurrentSyncSetting();
      const { owner, repo, branch } = currentSetting;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian4.Setting(containerEl).setName("Auto sync").setDesc(`Automatically sync your vault when remote has updates. (Muted: sync in the background without displaying notices, except for file changes and conflicts notice)`).addDropdown((dropdown) => {
        dropdown.addOption("off", "Off").addOption("muted", "Muted").addOption("remind", "Remind only").addOption("on", "On").setValue(this.plugin.storage.autoSync ? this.plugin.storage.autoSync : "off").onChange(async (value) => {
          this.plugin.storage.autoSync = value;
          checkIntervalSlider.settingEl.addClass(value === "off" ? "clear" : "restore");
          checkIntervalSlider.settingEl.removeClass(value === "off" ? "restore" : "clear");
          await this.plugin.saveSettings();
        });
      });
      const checkIntervalSlider = new import_obsidian4.Setting(containerEl).setName("Auto check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.storage.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.storage.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.storage.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
      if (this.plugin.storage.autoSync === "off") {
        checkIntervalSlider.settingEl.addClass("clear");
      }
    };
    this.noticeConfigBlock = () => {
      const { containerEl } = this;
      const selectedCol = "var(--interactive-accent)";
      const selectedTxtCol = "var(--text-on-accent)";
      const unselectedColor = "var(--interactive-normal)";
      const unselectedTxtCol = "var(--text-normal)";
      const stateTextMap = (notifyConflicts, notifyChanges) => {
        if (notifyConflicts && notifyChanges) {
          return "Displaying file changes and conflicts ";
        } else if (!notifyConflicts && notifyChanges) {
          return "Displaying file changes ";
        } else if (notifyConflicts && !notifyChanges) {
          return "Displaying change conflicts ";
        } else {
          return "No notice displayed ";
        }
      };
      const noticeDisplay = new import_obsidian4.Setting(containerEl).setName("Notice display").setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`).addButton((button) => {
        button.setButtonText("Change conflicts");
        button.onClick(async () => {
          const notifyConflicts = !this.plugin.storage.notifyConflicts;
          this.plugin.storage.notifyConflicts = notifyConflicts;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyConflicts ? selectedCol : unselectedColor,
            "color": notifyConflicts ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyConflicts ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyConflicts ? selectedTxtCol : unselectedTxtCol
        });
      }).addButton((button) => {
        button.setButtonText("File changes");
        button.onClick(async () => {
          const notifyChanges = !this.plugin.storage.notifyChanges;
          this.plugin.storage.notifyChanges = notifyChanges;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyChanges ? selectedCol : unselectedColor,
            "color": notifyChanges ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyChanges ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyChanges ? selectedTxtCol : unselectedTxtCol
        });
      });
    };
    this.counterRepoBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Manage repositories").setDesc("Add or remove repository configurations").addButton((button) => button.setButtonText("Add Repository").setCta().onClick(async () => {
        this.plugin.storage.repo.push(DEFAULT_REPOSITORY);
        await this.plugin.saveSettings();
        await this.display();
      })).addButton((button) => button.setButtonText("Remove Repository").setWarning().setDisabled(this.plugin.storage.repo.length <= 1).onClick(async () => {
        if (this.plugin.storage.repo.length > 1) {
          this.plugin.storage.repo.splice(this.currentSyncIndex, 1);
          if (this.currentSyncIndex >= this.plugin.storage.repo.length) {
            this.currentSyncIndex = this.plugin.storage.repo.length - 1;
          }
          await this.plugin.saveSettings();
          await this.display();
        }
      }));
      new import_obsidian4.Setting(containerEl).setName("Current repository").setDesc("Select which repository configuration to edit").addDropdown((dropdown) => {
        this.plugin.storage.repo.forEach((_, index) => {
          dropdown.addOption(index.toString(), `Repository ${index + 1}`);
        });
        dropdown.setValue(this.currentSyncIndex.toString());
        dropdown.onChange(async (value) => {
          this.currentSyncIndex = parseInt(value);
          await this.plugin.saveSettings();
          await this.display();
        });
      });
    };
    this.resetBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Reset settings").setDesc("Remove Sync storage or Settings").addButton((button) => button.setButtonText("Reset storage").setWarning().onClick(async () => {
        for (let storage of this.plugin.storage.repo) {
          storage.localStore = DEFAULT_LOCAL_STORE;
        }
        await this.plugin.saveSettings();
        await this.display();
      })).addButton((button) => button.setButtonText("Reset Settings").setWarning().onClick(async () => {
        this.plugin.storage.repo = [DEFAULT_REPOSITORY];
        await this.plugin.saveSettings();
        await this.display();
      }));
    };
    this.plugin = plugin;
  }
  getCurrentSyncSetting() {
    return this.plugin.storage.repo[this.currentSyncIndex].settings;
  }
  async githubUserInfoBlock() {
    const { containerEl } = this;
    const currentSetting = this.getCurrentSyncSetting();
    const allItems = await this.plugin.vaultOps.getAllInVault();
    const allPaths = [...allItems.folders, ...allItems.files];
    const { folders, files } = allItems;
    new import_obsidian4.Setting(containerEl).setHeading().setName(`GitHub user info (Repository ${this.currentSyncIndex + 1})`);
    new import_obsidian4.Setting(containerEl).setName("Github username").setDesc("Enter your name on Github").addText((text) => text.setPlaceholder("GitHub username").setValue(currentSetting.owner).onChange(async (value) => {
      currentSetting.owner = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Github personal access token").setDesc("Remember to give it access for reading and writing to the storage repo.").addText((text) => text.setPlaceholder("GitHub personal access token").setValue(currentSetting.pat).onChange(async (value) => {
      currentSetting.pat = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
      window.open("https://github.com/settings/tokens/new", "_blank");
    }));
    new import_obsidian4.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(currentSetting.deviceName).onChange(async (value) => {
      currentSetting.deviceName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Repository name").setDesc("Select a repo.").addText((text) => text.setPlaceholder("Repository").setValue(currentSetting.repo).onChange(async (value) => {
      currentSetting.repo = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Branch name").setDesc("Select a branch.").addText((text) => text.setPlaceholder("Branch").setValue(currentSetting.branch).onChange(async (value) => {
      currentSetting.branch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Sync path").setDesc("Select a local path to sync with the repo. If the field is empty, the entire vault will be synced.").addText(async (text) => {
      var _a;
      text.setPlaceholder("Enter folder path").setValue(currentSetting.syncPath || "").onChange(async (value) => {
        if (!folders2.contains(value))
          return;
        currentSetting.syncPath = value;
        await this.plugin.saveSettings();
      });
      const dataList = document.createElement("datalist");
      dataList.id = `folder-suggestions`;
      const otherSyncPath = /* @__PURE__ */ new Set();
      this.plugin.storage.repo.forEach(
        (el, i) => {
          if (i == this.currentSyncIndex)
            return;
          otherSyncPath.add(
            el.settings.syncPath
          );
        }
      );
      const allFolders = new Set(
        await this.plugin.vaultOps.getFoldersInVault()
      );
      const folders2 = Array.from(
        difference(allFolders, otherSyncPath)
      );
      for (let i in folders2) {
        const folder = folders2[i];
        const option = document.createElement("option");
        option.value = folder;
        dataList.appendChild(option);
      }
      text.inputEl.setAttribute("list", `folder-suggestions`);
      (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(dataList);
    });
    new import_obsidian4.Setting(containerEl).setName("View your vault on GitHub").addExtraButton(
      (button) => button.setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
        const link = this.getLatestLink();
        console.log(`opening ${link}`);
        window.open(link);
      })
    ).descEl.addClass("link-desc");
    new import_obsidian4.Setting(containerEl).setName("Excluded files/folders").setDesc("Files or folders within sync path that will not be synced").addButton((button) => button.setButtonText("Add exclusion").setCta().onClick(async () => {
      if (!currentSetting.excludes) {
        currentSetting.excludes = [];
      }
      currentSetting.excludes.push("");
      await this.plugin.saveSettings();
      await this.display();
    }));
    for (let index_ in currentSetting.excludes) {
      const index = Number(index_);
      const exclude = currentSetting.excludes[index];
      new import_obsidian4.Setting(containerEl).setName(`Exclusion ${index + 1}`).addText((text) => {
        var _a;
        text.setPlaceholder("path/to/exclude").setValue(exclude).onChange(async (value) => {
          if (!folders.contains(value) && !files.contains(value))
            return;
          currentSetting.excludes[index] = value;
          await this.plugin.saveSettings();
        });
        const dataList = document.createElement("datalist");
        dataList.id = `exclude-suggestions-${index}`;
        let filteredPaths = allPaths;
        if (currentSetting.syncPath) {
          filteredPaths = allPaths.filter(
            (path) => path.startsWith(currentSetting.syncPath + "/") || path === currentSetting.syncPath
          );
        }
        filteredPaths.forEach((path) => {
          const option = document.createElement("option");
          option.value = path;
          dataList.appendChild(option);
        });
        text.inputEl.setAttribute("list", `exclude-suggestions-${index}`);
        (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(dataList);
      }).addButton((button) => button.setIcon("trash").setTooltip("Remove this exclusion").onClick(async () => {
        currentSetting.excludes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.display();
      }));
    }
  }
  async getItemsInSyncPath() {
    const currentSetting = this.getCurrentSyncSetting();
    if (!currentSetting.syncPath)
      return [];
    try {
      const syncPath = currentSetting.syncPath;
      const allItems = [];
      const all = await this.plugin.vaultOps.getAllInVault();
      for (const file in all) {
        if (syncPath == "" || file.startsWith(syncPath + "/") || file === syncPath) {
          allItems.push(file);
        }
      }
      return allItems.sort();
    } catch (error) {
      console.error("Error getting items in sync path:", error);
      return [];
    }
  }
  importExport() {
    const { containerEl } = this;
    new import_obsidian4.Setting(containerEl).setName("Import/Export settings").setDesc("Backup or restore your plugin configuration").setHeading();
    const textAreaContainer = containerEl.createDiv("import-export-container");
    const textArea = textAreaContainer.createEl("textarea", {
      attr: {
        placeholder: "Configuration JSON will appear here...",
        rows: "10",
        style: "width: 100%; font-family: monospace;"
      },
      cls: "import-export-textarea"
    });
    new import_obsidian4.Setting(containerEl).addButton((button) => button.setButtonText("Export to Text Field").setCta().onClick(async () => {
      this.exportToTextField(textArea);
    })).addButton((button) => button.setButtonText("Import from Text Field").setWarning().onClick(async () => {
      await this.importFromTextField(textArea);
    })).addButton((button) => button.setButtonText("Clear Field").setIcon("trash").onClick(() => {
      textArea.value = "";
    }));
  }
  exportToTextField(textArea) {
    try {
      const result = structuredClone(this.plugin.storage);
      for (let i in result.repo) {
        delete result.repo[i].localStore;
      }
      const settingsJson = JSON.stringify(result, null, 4);
      textArea.value = settingsJson;
      textArea.focus();
      textArea.select();
    } catch (error) {
      console.error("Error exporting settings:", error);
      new import_obsidian4.Notice("Error exporting configuration", 3e3);
    }
  }
  async importFromTextField(textArea) {
    try {
      const jsonContent = textArea.value.trim();
      if (!jsonContent) {
        new import_obsidian4.Notice("Text field is empty", 3e3);
        return;
      }
      const importedSettings = JSON.parse(jsonContent);
      if (this.validateImportedSettings(importedSettings)) {
        for (let repo of importedSettings.repo) {
          repo.localStore = DEFAULT_LOCAL_STORE;
        }
        this.plugin.storage = importedSettings;
        await this.plugin.saveSettings();
        new import_obsidian4.Notice("Settings imported successfully!", 3e3);
        await this.display();
      } else {
        new import_obsidian4.Notice("Invalid settings format in text field", 4e3);
      }
    } catch (error) {
      console.error("Error importing settings from text field:", error);
      new import_obsidian4.Notice("Error parsing JSON configuration", 4e3);
    }
  }
  validateImportedSettings(settings) {
    return settings && typeof settings === "object" && Array.isArray(settings.repo) && settings.repo.length > 0 && settings.repo[0].settings && typeof settings.repo[0].settings === "object" && "syncPath" in settings.repo[0].settings;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.localConfigBlock();
    this.noticeConfigBlock();
    containerEl.createEl("hr");
    await this.importExport();
    containerEl.createEl("hr");
    this.counterRepoBlock();
    containerEl.createEl("hr");
    this.resetBlock();
    containerEl.createEl("hr");
    await this.githubUserInfoBlock();
  }
};

// src/fitSync.ts
var import_obsidian5 = require("obsidian");

// src/fitPull.ts
var FitPull = class {
  constructor(fit) {
    this.fit = fit;
  }
  async performPrePullChecks(localChanges) {
    const { remoteCommitSha, updated } = await this.fit.remoteUpdated();
    if (!updated) {
      return { status: "localCopyUpToDate", remoteUpdate: null };
    }
    if (!localChanges) {
      localChanges = await this.fit.getLocalChanges();
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    const clashedFiles = this.fit.getClashedChanges(localChanges, remoteChanges);
    const prePullCheckStatus = remoteChanges.length > 0 ? clashedFiles.length > 0 ? "localChangesClashWithRemoteChanges" : "remoteChangesCanBeMerged" : "noRemoteChangesDetected";
    return {
      status: prePullCheckStatus,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles
      }
    };
  }
  // Get changes from remote, pathShaMap is coupled to the Fit plugin design
  async getRemoteNonDeletionChangesContent(pathShaMap) {
    const remoteChanges = Object.entries(pathShaMap).map(async ([path, file_sha]) => {
      const content = await this.fit.getBlob(file_sha);
      return { path, content };
    });
    return await Promise.all(remoteChanges);
  }
  async prepareChangesToExecute(remoteChanges) {
    const deleteFromLocal = remoteChanges.filter((c) => c.status == "REMOVED").map((c) => c.path);
    const changesToProcess = remoteChanges.filter((c) => c.status != "REMOVED").reduce(
      (acc, change) => {
        acc[change.path] = change.currentSha;
        return acc;
      },
      {}
    );
    const addToLocal = await this.getRemoteNonDeletionChangesContent(changesToProcess);
    return { addToLocal, deleteFromLocal };
  }
  async pullRemoteToLocal(remoteUpdate, saveLocalStoreCallback) {
    const { remoteChanges, remoteTreeSha, latestRemoteCommitSha } = remoteUpdate;
    let { addToLocal, deleteFromLocal } = await this.prepareChangesToExecute(remoteChanges);
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const fileOpsRecord = await this.fit.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: remoteTreeSha,
        lastFetchedCommitSha: latestRemoteCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    return fileOpsRecord;
  }
};

// src/fitPush.ts
var FitPush = class {
  constructor(fit) {
    this.fit = fit;
  }
  async createCommitFromLocalUpdate(localUpdate, remoteTree) {
    const { localChanges, parentCommitSha } = localUpdate;
    const pushedChanges = [];
    const treeNodes = (await Promise.all(localChanges.map(async (f, i) => {
      const node = await this.fit.createTreeNodeFromFile(f, remoteTree);
      if (node) {
        pushedChanges.push(localChanges[i]);
        return node;
      }
    }))).filter(Boolean);
    console.log(treeNodes);
    if (treeNodes.length === 0) {
      return null;
    }
    const latestRemoteCommitTreeSha = await this.fit.getCommitTreeSha(parentCommitSha);
    const createdTreeSha = await this.fit.createTree(treeNodes, latestRemoteCommitTreeSha);
    const createdCommitSha = await this.fit.createCommit(createdTreeSha, parentCommitSha);
    return { createdCommitSha, pushedChanges };
  }
  async pushChangedFilesToRemote(localUpdate) {
    if (localUpdate.localChanges.length == 0) {
      return null;
    }
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.createCommitFromLocalUpdate(localUpdate, remoteTree);
    if (!createCommitResult) {
      return null;
    }
    const { createdCommitSha, pushedChanges } = createCommitResult;
    const updatedRefSha = await this.fit.updateRef(createdCommitSha);
    const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
    return {
      pushedChanges,
      lastFetchedRemoteSha: updatedRemoteTreeSha,
      lastFetchedCommitSha: createdCommitSha
    };
  }
};

// src/fitSync.ts
var FitSync = class {
  constructor(fit, vaultOps, saveLocalStoreCallback) {
    this.fit = fit;
    this.fitPull = new FitPull(fit);
    this.fitPush = new FitPush(fit);
    this.vaultOps = vaultOps;
    this.saveLocalStoreCallback = saveLocalStoreCallback;
  }
  async performPreSyncChecks() {
    const currentLocalSha = await this.fit.computeLocalSha();
    const localChanges = await this.fit.getLocalChanges(currentLocalSha);
    const { remoteCommitSha, updated: remoteUpdated } = await this.fit.remoteUpdated();
    if (localChanges.length === 0 && !remoteUpdated) {
      return { status: "inSync" };
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    let clashes = [];
    let status;
    if (localChanges.length > 0 && !remoteUpdated) {
      status = "onlyLocalChanged";
    } else if (remoteUpdated && localChanges.length === 0 && remoteChanges.length === 0) {
      status = "onlyRemoteCommitShaChanged";
    } else if (localChanges.length === 0 && remoteUpdated) {
      status = "onlyRemoteChanged";
    } else {
      clashes = this.fit.getClashedChanges(localChanges, remoteChanges);
      if (clashes.length === 0) {
        status = "localAndRemoteChangesCompatible";
      } else {
        status = "localAndRemoteChangesClashed";
      }
    }
    return {
      status,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles: clashes
      },
      localChanges,
      localTreeSha: currentLocalSha
    };
  }
  generateConflictReport(path, localContent, remoteContent) {
    const detectedExtension = extractExtension(path);
    let resolutionStrategy = "utf-8";
    if (detectedExtension && !RECOGNIZED_TXT_EXT.includes(detectedExtension))
      resolutionStrategy = "binary";
    return {
      path,
      resolutionStrategy,
      localContent,
      remoteContent
    };
  }
  async handleBinaryConflict(path, localContent, remoteContent) {
    const conflictPath = this.fit.syncPath + path;
    const conflictResolutionPath = conflictResolutionFolder + conflictPath;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await Promise.all([
      this.fit.vaultOps.writeToLocal(conflictPath, remoteContent),
      this.fit.vaultOps.writeToLocal(conflictResolutionPath, localContent)
    ]);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleUTF8Conflict(path, localContent, remoteContent) {
    const conflictPath = this.fit.syncPath + path;
    const conflictResolutionPath = conflictResolutionFolder + conflictPath;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await Promise.all([
      this.fit.vaultOps.writeToLocal(conflictPath, remoteContent),
      this.fit.vaultOps.writeToLocal(conflictResolutionPath, localContent)
    ]);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleLocalDeletionConflict(path, remoteContent) {
    const conflictResolutionPath = this.fit.syncPath + path;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async resolveFileConflict(clash, latestRemoteFileSha) {
    if (clash.localStatus === "deleted" && clash.remoteStatus === "REMOVED") {
      return { path: clash.path, noDiff: true };
    } else if (clash.localStatus === "deleted") {
      const remoteContent2 = await this.fit.getBlob(latestRemoteFileSha);
      const fileOp = await this.handleLocalDeletionConflict(clash.path, remoteContent2);
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    const path = this.fit.syncPath + clash.path;
    const localFileContent = (0, import_obsidian5.arrayBufferToBase64)(
      await this.fit.vaultOps.vault.adapter.readBinary(path)
    );
    if (!latestRemoteFileSha)
      return { path: clash.path, noDiff: false };
    const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
    if (removeLineEndingsFromBase64String(remoteContent) !== removeLineEndingsFromBase64String(localFileContent)) {
      const report = this.generateConflictReport(clash.path, localFileContent, remoteContent);
      let fileOp;
      if (report.resolutionStrategy === "binary") {
        fileOp = await this.handleBinaryConflict(clash.path, report.localContent, report.remoteContent);
      } else {
        fileOp = await this.handleUTF8Conflict(clash.path, report.localContent, report.remoteContent);
      }
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    return { path: clash.path, noDiff: true };
  }
  async resolveConflicts(clashedFiles, latestRemoteTreeSha) {
    const fileResolutions = await Promise.all(
      clashedFiles.map(
        async (clash) => {
          return await this.resolveFileConflict(clash, latestRemoteTreeSha[clash.path]);
        }
      )
    );
    const unresolvedFiles = fileResolutions.map((res, i) => {
      if (!(res == null ? void 0 : res.noDiff)) {
        return clashedFiles[i];
      }
      return null;
    }).filter(Boolean);
    return {
      noConflict: fileResolutions.every((res) => res == null ? void 0 : res.noDiff),
      unresolvedFiles,
      fileOpsRecord: fileResolutions.map((r) => r == null ? void 0 : r.fileOp).filter(Boolean)
    };
  }
  async syncCompatibleChanges(localUpdate, remoteUpdate, syncNotice) {
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(
      remoteUpdate.remoteChanges
    );
    syncNotice.setMessage("Uploading local changes");
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.fitPush.createCommitFromLocalUpdate(localUpdate, remoteTree);
    let latestRemoteTreeSha;
    let latestCommitSha;
    let pushedChanges;
    if (createCommitResult) {
      const { createdCommitSha } = createCommitResult;
      const latestRefSha = await this.fit.updateRef(createdCommitSha);
      latestRemoteTreeSha = await this.fit.getRemoteTreeSha(latestRefSha);
      latestCommitSha = createdCommitSha;
      pushedChanges = createCommitResult.pushedChanges;
    } else {
      latestRemoteTreeSha = remoteUpdate.remoteTreeSha;
      latestCommitSha = remoteUpdate.latestRemoteCommitSha;
      pushedChanges = [];
    }
    syncNotice.setMessage("Writing remote changes to local");
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: latestRemoteTreeSha,
        lastFetchedCommitSha: latestCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    syncNotice.setMessage("Sync successful");
    return { localOps: localFileOpsRecord, remoteOps: pushedChanges };
  }
  async syncWithConflicts(localChanges, remoteUpdate, syncNotice) {
    const { latestRemoteCommitSha, clashedFiles, remoteTreeSha: latestRemoteTreeSha } = remoteUpdate;
    const { noConflict, unresolvedFiles, fileOpsRecord } = await this.resolveConflicts(clashedFiles, latestRemoteTreeSha);
    let localChangesToPush;
    let remoteChangesToWrite;
    if (noConflict) {
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !localChanges.some((l) => l.path === c.path));
      localChangesToPush = localChanges.filter((c) => !remoteUpdate.remoteChanges.some((r) => r.path === c.path));
    } else {
      syncNotice.setMessage(`Change conflicts detected`);
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !unresolvedFiles.some((l) => l.path === c.path));
      localChangesToPush = localChanges;
    }
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(remoteChangesToWrite);
    const syncLocalUpdate = {
      localChanges: localChangesToPush,
      parentCommitSha: latestRemoteCommitSha
    };
    const pushResult = await this.fitPush.pushChangedFilesToRemote(syncLocalUpdate);
    let pushedChanges;
    let lastFetchedCommitSha;
    let lastFetchedRemoteSha;
    if (pushResult) {
      pushedChanges = pushResult.pushedChanges;
      lastFetchedCommitSha = pushResult.lastFetchedCommitSha;
      lastFetchedRemoteSha = pushResult.lastFetchedRemoteSha;
    } else {
      pushedChanges = [];
      lastFetchedCommitSha = remoteUpdate.latestRemoteCommitSha;
      lastFetchedRemoteSha = remoteUpdate.remoteTreeSha;
    }
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha,
        lastFetchedCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    const ops = localFileOpsRecord.concat(fileOpsRecord);
    if (unresolvedFiles.length === 0) {
      syncNotice.setMessage(`Sync successful`);
    } else if (unresolvedFiles.some((f) => f.remoteStatus !== "REMOVED")) {
      syncNotice.setMessage(`Synced with remote, unresolved conflicts written to ${conflictResolutionFolder}`);
    } else {
      syncNotice.setMessage(`Synced with remote, ignored remote deletion of locally changed files`);
    }
    return { unresolvedFiles, localOps: ops, remoteOps: pushedChanges };
  }
  async unresolvedChangesConflicts() {
    return await this.vaultOps.vault.adapter.exists(conflictResolutionFolder);
  }
  async sync(syncNotice) {
    syncNotice.setMessage("Performing pre sync checks.");
    if (await this.unresolvedChangesConflicts()) {
      syncNotice.setMessage(`There are unresolved files: pls, resolve files in: ${conflictResolutionFolder}.`);
      return;
    }
    const preSyncCheckResult = await this.performPreSyncChecks();
    if (preSyncCheckResult.status === "inSync") {
      syncNotice.setMessage("Sync successful");
      return;
    }
    if (preSyncCheckResult.status === "onlyRemoteCommitShaChanged") {
      const { latestRemoteCommitSha } = preSyncCheckResult.remoteUpdate;
      await this.saveLocalStoreCallback(
        this.fit.syncPath,
        { lastFetchedCommitSha: latestRemoteCommitSha }
      );
      syncNotice.setMessage("Sync successful");
      return;
    }
    const remoteUpdate = preSyncCheckResult.remoteUpdate;
    if (preSyncCheckResult.status === "onlyRemoteChanged") {
      const fileOpsRecord = await this.fitPull.pullRemoteToLocal(
        remoteUpdate,
        this.saveLocalStoreCallback
      );
      syncNotice.setMessage("Sync successful");
      return {
        ops: [{ heading: "Local file updates:", ops: fileOpsRecord }],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    const { localChanges, localTreeSha } = preSyncCheckResult;
    const localUpdate = {
      localChanges,
      parentCommitSha: remoteUpdate.latestRemoteCommitSha
    };
    if (preSyncCheckResult.status === "onlyLocalChanged") {
      syncNotice.setMessage("Uploading local changes");
      const pushResult = await this.fitPush.pushChangedFilesToRemote(localUpdate);
      syncNotice.setMessage("Sync successful");
      if (pushResult) {
        await this.saveLocalStoreCallback(
          this.fit.syncPath,
          {
            localSha: localTreeSha,
            lastFetchedRemoteSha: pushResult.lastFetchedRemoteSha,
            lastFetchedCommitSha: pushResult.lastFetchedCommitSha
          }
        );
        return {
          ops: [{ heading: "Local file updates:", ops: pushResult.pushedChanges }],
          clash: []
          // basepath: this.fit.syncPath
        };
      }
      return;
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesCompatible") {
      const { localOps, remoteOps } = await this.syncCompatibleChanges(
        localUpdate,
        remoteUpdate,
        syncNotice
      );
      return {
        ops: [
          { heading: "Local file updates:", ops: localOps },
          { heading: "Remote file updates:", ops: remoteOps }
        ],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesClashed") {
      const conflictResolutionResult = await this.syncWithConflicts(
        localUpdate.localChanges,
        remoteUpdate,
        syncNotice
      );
      if (conflictResolutionResult) {
        const { unresolvedFiles, localOps, remoteOps } = conflictResolutionResult;
        return {
          ops: [
            { heading: "Local file updates:", ops: localOps },
            { heading: "Remote file updates:", ops: remoteOps }
          ],
          clash: unresolvedFiles
          // basepath: this.fit.syncPath
        };
      }
    }
  }
};

// src/vaultOps.ts
var import_obsidian6 = require("obsidian");
var VaultOperations = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getTFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      return file;
    } else {
      return null;
    }
  }
  async deleteFromLocal(path) {
    const isExists = await this.vault.adapter.exists(path);
    if (!isExists) {
      console.error(`Attempting to read ${path} from local drive but not successful:
                the file doesn't exists`);
      return null;
    }
    await this.vault.adapter.remove(path);
    return { path, status: "deleted" };
  }
  // if checking a folder, require including the last / in the path param
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath == "") {
      return false;
    }
    const parts = folderPath.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath += part + "/";
      try {
        const isExists = await this.vault.adapter.exists(currentPath, true);
        if (isExists)
          continue;
        await this.vault.adapter.mkdir(currentPath);
      } catch (e) {
        return false;
      }
    }
    return true;
  }
  async writeToLocal(path, content) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "changed" };
    } else {
      await this.ensureFolderExists(path);
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "created" };
    }
  }
  async updateLocalFiles(addToLocal, deleteFromLocal) {
    const writeOperations = addToLocal.map(async ({ path, content }) => {
      return await this.writeToLocal(path, content);
    });
    const deletionOperations = deleteFromLocal.map(async (path) => {
      return await this.deleteFromLocal(path);
    });
    const fileOps = await Promise.all([...writeOperations, ...deletionOperations]);
    return fileOps;
  }
  // TODO    ,   
  async createCopyInDir(path, copyDir = conflictResolutionFolder) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      const copyPath = copyDir + path;
      const copy = await this.vault.adapter.readBinary(path);
      await this.ensureFolderExists(copyPath);
      await this.vault.adapter.writeBinary(copyPath, copy);
      await this.vault.adapter.writeBinary(copyPath, copy);
    } else {
      throw new Error(`Attempting to create copy of ${path} from local drive as TFile but not successful,
            file is of type ${typeof file}.`);
    }
  }
  async getAllInObsidian() {
    const rootPath = this.vault.configDir;
    const folders = [rootPath + "/"];
    const files = [];
    const traverseDirectory = async (path) => {
      let items;
      try {
        items = await this.vault.adapter.list(path);
      } catch (error) {
        return null;
      }
      for (const folder of items.folders) {
        await traverseDirectory(folder);
        let folderPath = folder.startsWith("/") ? folder.slice(1) : folder;
        folderPath = folderPath === "" ? "" : `${folderPath}/`;
        folders.push(folderPath);
      }
      for (const file of items.files) {
        let filePath = file.startsWith("/") ? file.slice(1) : file;
        files.push(filePath);
      }
    };
    await traverseDirectory(rootPath);
    return { folders, files };
  }
  async getAllInVault() {
    const all = this.vault.getAllLoadedFiles();
    const folders = [];
    const files = [];
    for (let file of all) {
      if (file instanceof import_obsidian6.TFolder) {
        let path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        path = path == "" ? "" : `${path}/`;
        folders.push(path);
      } else if (file instanceof import_obsidian6.TFile) {
        const path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        files.push(path);
      }
    }
    const obsidianItems = await this.getAllInObsidian();
    const [obsidianFiles, obsidianFolders] = [obsidianItems.files, obsidianItems.folders];
    folders.push(...obsidianFolders);
    files.push(...obsidianFiles);
    return { folders, files };
  }
  async getFoldersInVault() {
    const { folders } = await this.getAllInVault();
    return folders;
  }
  async getFilesInVault() {
    const { files } = await this.getAllInVault();
    return files;
  }
};

// main.ts
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var DEFAULT_REPOSITORY = {
  settings: {
    pat: "",
    owner: "",
    avatarUrl: "",
    repo: "",
    branch: "",
    syncPath: "",
    deviceName: "",
    excludes: []
  },
  localStore: { ...DEFAULT_LOCAL_STORE }
};
var DEFAULT_SETTINGS = {
  repo: [DEFAULT_REPOSITORY],
  checkEveryXMinutes: 5,
  autoSync: "off",
  notifyChanges: true,
  notifyConflicts: true
};
var FitPlugin2 = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    // localStore: LocalStores
    this.fits = [];
    this.fitSync = [];
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (path, localStore) => {
      const i = this.storage.repo.findIndex(
        (storage, _) => storage.settings.syncPath === path
      );
      if (i < 0) {
        return;
      }
      await this.loadSettings();
      this.storage.repo[i].localStore = {
        ...this.storage.repo[i].localStore,
        ...localStore
      };
      await this.saveSettings();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      for (let i_ in this.fitSync) {
        let i = Number(i_);
        const fitSync = this.fitSync[i];
        const syncRecords = await fitSync.sync(syncNotice);
        if (!syncRecords)
          continue;
        let { ops, clash } = syncRecords;
        const basepath = this.storage.repo[i].settings.syncPath;
        clash = clash.map(
          (el) => {
            return {
              ...el,
              path: basepath + el.path
            };
          }
        );
        if (this.storage.notifyConflicts)
          showUnappliedConflicts(clash);
        if (this.storage.notifyChanges)
          showFileOpsRecord(ops);
      }
    };
    // wrapper to convert error to notice, return true if error is caught
    this.catchErrorAndNotify = async (func, notice, ...args) => {
      try {
        const result = await func(notice, ...args);
        return result;
      } catch (error) {
        if (error instanceof OctokitHttpError) {
          console.log("error.status");
          console.log(error.status);
          switch (error.source) {
            case "getTree":
            case "getRef":
              console.error("Caught error from getRef: ", error.message);
              if (error.status === 404) {
                notice.setMessage("Failed to get ref, make sure your repo name and branch name are set correctly.", true);
                return true;
              }
              notice.setMessage("Unknown error in getting ref, refers to console for details.", true);
              return true;
            case "getCommitTreeSha":
            case "getRemoteTreeSha":
            case "createBlob":
            case "createTreeNodeFromFile":
            case "createCommit":
            case "updateRef":
            case "getBlob":
          }
          return true;
        }
        console.error("Caught unknown error: ", error);
        notice.setMessage("Unable to sync, if you are not connected to the internet, turn off auto sync.", true);
        return true;
      }
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  async checkSettingsConfigured() {
    const actionItems = [];
    const settings = this.storage.repo;
    const folders = await this.vaultOps.getFoldersInVault();
    const setSyncPath = /* @__PURE__ */ new Set();
    for (let i_ in settings) {
      const i = Number(i_);
      const currentSetting = settings[i].settings;
      if (currentSetting.pat === "") {
        actionItems.push(`provide GitHub personal access token for repository: ${i + 1}`);
      }
      if (currentSetting.owner === "") {
        actionItems.push(`enter your Github nickname for repository: ${i + 1}`);
      }
      if (currentSetting.repo === "") {
        actionItems.push(`enter a repository to sync: ${i + 1}`);
      }
      if (currentSetting.branch === "") {
        actionItems.push(`enter a branch to sync: ${i + 1}`);
      }
      if (!folders.contains(currentSetting.syncPath)) {
        actionItems.push(`enter a directory (syncPath): ${i + 1}`);
      }
      for (let exlude of currentSetting.excludes) {
        if (exlude.startsWith(currentSetting.syncPath)) {
          continue;
        }
        actionItems.push(`enter a proper exlude (in syncPath) for repository: ${i + 1}`);
        break;
      }
      setSyncPath.add(currentSetting.syncPath);
    }
    if (setSyncPath.size != settings.length) {
      actionItems.push("Remove duplicate syncPaths");
    }
    if (actionItems.length > 0) {
      const initialMessage = "Settings not configured, please complete the following action items:\n" + actionItems.join("\n");
      const settingsNotice = new FitNotice(["static"], initialMessage);
      settingsNotice.remove("static");
      return false;
    }
    return true;
  }
  async getDiff() {
    const files = await this.vaultOps.getFilesInVault();
    const conflictFiles = files.filter(
      (el) => el.startsWith(conflictResolutionFolder)
    );
    const conflictStatuses = await this.getConflictStatus(conflictFiles);
    const text = await this.getTextByConflictStatuses(conflictStatuses);
    await this.vaultOps.vault.adapter.write(conflictReportPath, text);
    this.app.workspace.getLeaf(true).openFile(
      this.vaultOps.vault.getFileByPath(conflictReportPath)
    );
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Fit Sync", async (evt) => {
      if (this.syncing || this.autoSyncing) {
        return;
      }
      this.syncing = true;
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = new FitNotice(["loading"], "Initiating sync");
      const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        syncNotice.remove("error");
        this.syncing = false;
        return;
      }
      syncNotice.remove("done");
      this.syncing = false;
    });
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
    this.addRibbonIcon(
      "git-compare-arrows",
      "Fit: show diff",
      async () => {
        const res = await this.getDiff();
      }
    );
  }
  async autoSync() {
    if (this.syncing || this.autoSyncing) {
      return;
    }
    this.autoSyncing = true;
    const syncNotice = new FitNotice(
      ["loading"],
      "Auto syncing",
      0,
      this.storage.autoSync === "muted"
    );
    const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
    if (errorCaught === true) {
      syncNotice.remove("error");
    } else {
      syncNotice.remove();
    }
    this.autoSyncing = false;
  }
  async autoUpdate() {
    if (!(this.storage.autoSync === "off") && !this.syncing && !this.autoSyncing && await this.checkSettingsConfigured()) {
      if (this.storage.autoSync === "on" || this.storage.autoSync === "muted") {
        await this.autoSync();
      } else if (this.storage.autoSync === "remind") {
        for (let fit of this.fits) {
          const { updated } = await fit.remoteUpdated();
          if (updated) {
            const initialMessage = "Remote update detected, please pull the latest changes.";
            const intervalNotice = new FitNotice(["static"], initialMessage);
            intervalNotice.remove("static");
          }
        }
      }
    }
  }
  async startOrUpdateAutoSyncInterval() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      await this.autoUpdate();
    }, this.storage.checkEveryXMinutes * 60 * 1e3);
  }
  async onload() {
    await this.loadSettings();
    this.vaultOps = new VaultOperations(this.app.vault);
    const excludes = this.getExcludes();
    for (let repo_ of this.storage.repo) {
      let repo = structuredClone(repo_);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      const fit = new Fit(repo, this.vaultOps);
      this.fits.push(fit);
      this.fitSync.push(
        new FitSync(fit, this.vaultOps, this.saveLocalStoreCallback)
      );
    }
    this.syncing = false;
    this.autoSyncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addSettingTab(new FitSettingTab(this.app, this));
    await this.startOrUpdateAutoSyncInterval();
  }
  onunload() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else if (key === "notifyChanges" || key === "notifyConflicts") {
            obj[key] = Boolean(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.storage = settingsObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const result = { ...data, ...this.storage };
    await this.saveData(result);
    const excludes = this.getExcludes();
    for (let i in this.fits) {
      let repo = structuredClone(this.storage.repo[i]);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      this.fits[i].loadSettings(repo);
    }
    this.startOrUpdateAutoSyncInterval();
  }
  getExcludes() {
    const excludes = [];
    for (let repo of this.storage.repo) {
      const path = repo.settings.syncPath;
      if (path)
        excludes.push(path);
    }
    return excludes;
  }
  async getConflictStatus(conflictFiles) {
    const res = [];
    for (let file of conflictFiles) {
      let newFile = file.slice(conflictResolutionFolder.length);
      const isDeleted = !await this.vaultOps.vault.adapter.exists(newFile);
      const isBinary = isBinaryFile(file);
      res.push({
        oldFilePath: file,
        newFilePath: newFile,
        isDeleted,
        isBinary
      });
    }
    return res;
  }
  async getTextByConflictStatuses(statuses) {
    let result = "";
    const templateStart = "start of the: ";
    const templateEnd = "end of the: ";
    for (let status of statuses) {
      result += basicTemplateConflict + templateStart + status.newFilePath + "\n";
      if (status.isDeleted) {
        result += "local:  changed\n";
        result += "remote: deleted";
      } else if (status.isBinary) {
        result += "both file was modified:";
        result += `	old: ${status.oldFilePath}`;
        result += `	new: ${status.newFilePath}`;
      } else {
        result += getDiffText(
          await this.vaultOps.vault.adapter.read(status.oldFilePath),
          await this.vaultOps.vault.adapter.read(status.newFilePath)
        );
      }
      result += "\n";
      result += basicTemplateConflict + templateEnd + status.newFilePath + "\n";
      result += "\n\n\n";
    }
    return result;
  }
};
